// This file is part of WADBD
// https://github.com/rhythmcache 
// https://rhythmcache.t.me 

const MODULE_PATH = '/data/adb/modules/wadbd';
let callbackCounter = 0;
const themes = ['light', 'amoled', 'dark', 'light-blue', 'pink', 'blackpink', 'dpink', 'space', 'forest'];
let currentThemeIndex = localStorage.getItem('themeIndex') ? parseInt(localStorage.getItem('themeIndex')) : 0;
let isEnvironmentSupported = true;

let showNotifications = localStorage.getItem('showNotifications') === 'true';

function toggleInfoDialog() {
    const dialog = document.getElementById('infoDialog');
    if (dialog.style.display === 'none') {
        dialog.style.display = 'flex';
        fetchReadme();
    } else {
        dialog.style.display = 'none';
    }
}

function toggleSettingsMenu() {
    const settingsMenu = document.getElementById('settingsMenu');
    settingsMenu.style.display = settingsMenu.style.display === 'none' ? 'flex' : 'none';
}

document.addEventListener('click', function(event) {
    const settingsMenu = document.getElementById('settingsMenu');
    const settingsButton = document.querySelector('.settings-button');
    if (!settingsMenu.contains(event.target) && !settingsButton.contains(event.target)) {
        settingsMenu.style.display = 'none';
    }
});

async function fetchReadme() {
    const readmeContent = document.getElementById('readmeContent');
    const readmeUrl = 'https://raw.githubusercontent.com/Magisk-Modules-Alt-Repo/wadbd/main/info.md';

    try {
        const response = await fetch(readmeUrl);
        if (!response.ok) throw new Error('Failed to fetch README.md');
        const text = await response.text();
        readmeContent.innerHTML = parseMarkdown(text);
    } catch (error) {
        readmeContent.innerHTML = `<div class="error-message">Failed to load README.md: ${error.message}</div>`;
    }
}

// Simple Readme md parser
function parseMarkdown(markdown) {
    markdown = markdown.trim();
    markdown = markdown
        .replace(/^#### (.*$)/gim, '<h4>$1</h4>')
        .replace(/^### (.*$)/gim, '<h3>$1</h3>')
        .replace(/^## (.*$)/gim, '<h2>$1</h2>')
        .replace(/^# (.*$)/gim, '<h1>$1</h1>');
    const shieldBadgeRegex = /!\[([^\]]*)\]\((https:\/\/img\.shields\.io\/[^)]+)\)/g;
    markdown = markdown.replace(shieldBadgeRegex, (match, alt, url) => {
        return `<img class="shield-badge" alt="${alt}" src="${url}" />`;
    });
    const imageGroupRegex = /<div style="display: flex[^>]*>([\s\S]*?)<\/div>/g;
    markdown = markdown.replace(imageGroupRegex, (match, content) => {
        const images = content.match(/\<img[^>]*>/g) || [];
        return `<div class="image-group">${images.join('')}</div>`;
    });
    const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
    markdown = markdown.replace(imageRegex, (match, alt, url) => {
        return `<img class="markdown-image" alt="${alt}" src="${url}" />`;
    });
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    markdown = markdown.replace(codeBlockRegex, (match, language, code) => {
        return `<pre class="code-block ${language || ''}"><code>${code.trim()}</code></pre>`;
    });
    markdown = markdown.replace(/`([^`]+)`/g, '<code>$1</code>');
    markdown = markdown
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>');
    const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
    markdown = markdown.replace(linkRegex, (match, text, url) => {
        if (url.includes('img.shields.io')) {
            return `<img class="shield-badge" alt="${text}" src="${url}" />`;
        }
        return `<a href="javascript:void(0)" onclick="openLink('${url}')">${text}</a>`;
    });
    markdown = markdown.replace(/^-{3,}/gm, '<hr>');
    const listItems = markdown.split('\n');
    markdown = listItems.map(line => {
        if (/^\s*\d+\.\s+/.test(line)) {
            return line.replace(/^\s*\d+\.\s+(.*)/, '<li>$1</li>');
        }
        if (/^\s*[\-\*]\s+/.test(line)) {
            return line.replace(/^\s*[\-\*]\s+(.*)/, '<li>$1</li>');
        }
        return line;
    }).join('\n');
    markdown = markdown
        .replace(/((?:<li>.*<\/li>\n?)+)/g, '<ul>$1</ul>')
        .replace(/<ul>(\s*<li>\d+\.)/g, '<ol>$1');
    markdown = markdown
        .split(/\n\n+/)
        .map(para => {
            if (/^<[a-z/]/.test(para)) return para;
            if (!para.trim()) return '';
            return `<p>${para.replace(/\n/g, ' ').trim()}</p>`;
        })
        .filter(para => para)
        .join('\n');

    return markdown;
}
function openLink(url) {
    if (typeof ksu !== 'undefined' && ksu.exec) {
        ksu.exec(`am start -a android.intent.action.VIEW -d "${url}"`, '{}', 'openLink_callback');
    } else {
        window.open(url, '_blank');
    }
}
// Updated Styles
const markdownStyles = `
.shield-badge {
    height: 28px;
    margin-right: 8px;
    margin-bottom: 8px;
    display: inline-block;
    vertical-align: middle;
}

.image-group {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 16px;
    margin: 16px 0;
    flex-wrap: wrap;
}

.markdown-image {
    max-width: 100%;
    height: auto;
}

.code-block {
    background-color: #f6f8fa;
    padding: 16px;
    border-radius: 6px;
    overflow-x: auto;
    margin: 16px 0;
    font-family: monospace;
}

code {
    background-color: #f6f8fa;
    padding: 2px 4px;
    border-radius: 3px;
    font-family: monospace;
    font-size: 0.9em;
}

h1, h2, h3, h4 {
    margin-top: 24px;
    margin-bottom: 16px;
    font-weight: 600;
    line-height: 1.25;
}

h1 { font-size: 2em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1em; }

ul, ol {
    padding-left: 24px;
    margin: 16px 0;
}

li {
    margin: 8px 0;
}

hr {
    height: 0.25em;
    padding: 0;
    margin: 24px 0;
    background-color: #e1e4e8;
    border: 0;
}

p {
    margin: 16px 0;
    line-height: 1.5;
}
`;
// end


function setTheme(index) {
    const theme = themes[index];
    document.body.setAttribute('data-theme', theme === 'dark' ? '' : theme);
    localStorage.setItem('themeIndex', index);
}

function toggleTheme() {
    currentThemeIndex = (currentThemeIndex + 1) % themes.length;
    setTheme(currentThemeIndex);
}

function getUniqueCallbackName(base) {
    return `${base}_${Date.now()}_${callbackCounter++}`;
}

function alert(message) {
    if (typeof ksu !== 'undefined' && ksu.toast) {
        ksu.toast(message);
    } else {
        console.log(`Toast: ${message}`);
    }
}

function toggleInfoDialog() {
    const dialog = document.getElementById('infoDialog');
    if (dialog.style.display === 'none') {
        dialog.style.display = 'flex';
        fetchReadme();
    } else {
        dialog.style.display = 'none';
    }
}


async function exec(command) {
    return new Promise((resolve, reject) => {
        const callbackName = getUniqueCallbackName('exec');
        window[callbackName] = (errno, stdout, stderr) => {
            resolve({ errno, stdout: stdout.trim(), stderr });
            delete window[callbackName];
        };
        try {
            ksu.exec(command, '{}', callbackName);
        } catch (error) {
            reject(error);
            delete window[callbackName];
        }
    });
}

async function initializeEnvironment() {
    try {
        if (typeof ksu === 'undefined' || !ksu.exec) {
            isEnvironmentSupported = false;

            if (typeof mmrl !== 'undefined' && typeof $wadbd !== 'undefined') {
                document.getElementById('ksuDialog').style.display = 'flex';

                // Request KernelSU API in MMRL
                try {
                    $wadbd.requestAdvancedKernelSUAPI();
                } catch (error) {
                    console.log("Error requesting KernelSU API:", error);
                }
            }
            return;
        }

        const { errno } = await exec('id');
        isEnvironmentSupported = errno === 0;
    } catch {
        isEnvironmentSupported = false;
    }

    updateStatus();
    updateDeviceInfo();
}


async function updateDeviceInfo() {
    const deviceInfoDiv = document.getElementById('deviceInfo');
    
    if (!isEnvironmentSupported) {
        deviceInfoDiv.innerHTML = '<div class="error-message">Kernel SU API is missing. Unsupported Environment</div>';
        return;
    }

    try {
        const [
            { stdout: deviceCodename },
            { stdout: deviceName },
            { stdout: androidVersion },
            { stdout: securityPatch },
            { stdout: kernelVersion }
        ] = await Promise.all([
            exec('getprop ro.product.device'),
            exec('getprop ro.product.model'),
            exec('getprop ro.build.version.release'),
            exec('getprop ro.build.version.security_patch'),
            exec('uname -r')
        ]);

        deviceInfoDiv.innerHTML = `
            <div class="info-item">
                <span class="info-label">Device Codename :</span>
                <span class="info-value">${deviceCodename || 'Unknown'}</span>
            </div>
            <div class="info-item">
                <span class="info-label">Device Name :</span>
                <span class="info-value">${deviceName || 'Unknown'}</span>
            </div>
            <div class="info-item">
                <span class="info-label">Android Version :</span>
                <span class="info-value">${androidVersion || 'Unknown'}</span>
            </div>
            <div class="info-item">
                <span class="info-label">Security Patch :</span>
                <span class="info-value">${securityPatch || 'Unknown'}</span>
            </div>
            <div class="info-item">
                <span class="info-label">Kernel Version :</span>
                <span class="info-value">${kernelVersion || 'Unknown'}</span>
            </div>
        `;
    } catch (error) {
        deviceInfoDiv.innerHTML = '<div class="error-message">Error fetching device information</div>';
    }
}

document.addEventListener("DOMContentLoaded", function () {
    const wirelessToggle = document.getElementById("wirelessToggle");
    const portInput = document.getElementById("portInput");
    const changePortBtn = document.getElementById("changePortBtn");

    portInput.addEventListener("input", function () {
        if (this.value.length > 5) {
            this.value = this.value.slice(0, 5);
        }
    });

    function isValidPort(port) {
        return port === "" || (/^\d{1,5}$/.test(port) && port >= 1025 && port <= 65535);
    }

    wirelessToggle.addEventListener("change", function () {
        const port = portInput.value.trim();

        if (this.checked) {
            if (!isValidPort(port)) {
                alert("❌ Invalid port! Enter a port between 1024 and 65535.");
                this.checked = false; 
            }
        }
    });
    changePortBtn.addEventListener("click", function () {
        const port = portInput.value.trim();
        if (!isValidPort(port)) {
            alert("❌ Invalid port! Enter a port between 1024 and 65535.");
        } else {
            alert(`✅ Port changed to: ${port || "5555"}`);
        }
    });
});

async function getBootPort() {
    try {
        const { stdout: serviceContent } = await exec(`cat "${MODULE_PATH}/service.sh"`);
        const portMatch = serviceContent.match(/setprop service\.adb\.tcp\.port (\d+)/);
        return portMatch ? portMatch[1] : null;
    } catch {
        return null;
    }
}

async function updateStatus() {
    const statusDiv = document.getElementById('statusOutput');
    
    if (!isEnvironmentSupported) {
        statusDiv.innerHTML = '<div class="error-message">Kernel SU API is missing. Unsupported Environment.</div>';
        setAllControlsDisabled(true);
        return;
    }

    try {
        const [
            { stdout: usbDebug },
            { stdout: wirelessPort },
            { stdout: adbdStatus }
        ] = await Promise.all([
            exec('settings get global adb_enabled'),
            exec('getprop service.adb.tcp.port'),
            exec('getprop init.svc.adbd')
        ]);

        const bootEnabled = await checkBootStatus();
        const bootPort = await getBootPort();
        const isWirelessEnabled = wirelessPort !== '' && wirelessPort !== '-1';

        statusDiv.innerHTML = `
            <div class="status-item">
                <span class="status-label">USB Debugging : </span>
                <span>${usbDebug === '1' ? 'Enabled' : 'Disabled'}</span>
            </div>
            <div class="status-item">
                <span class="status-label">Wireless ADB : </span>
                <span>${isWirelessEnabled ? `Enabled (Port ${wirelessPort})` : 'Disabled'}</span>
            </div>
            <div class="status-item">
                <span class="status-label">ADB Daemon : </span>
                <span>${adbdStatus || 'Unknown'}</span>
            </div>
            <div class="status-item">
                <span class="status-label">WADBD on Boot : </span>
                <span>${bootEnabled ? `Enabled (Port ${bootPort || 'Unknown'})` : 'Not enabled'}</span>
            </div>
        `;
        document.getElementById('usbDebugToggle').checked = usbDebug === '1';
        document.getElementById('wirelessToggle').checked = isWirelessEnabled;
        document.getElementById('bootToggle').checked = bootEnabled;
        
        setAllControlsDisabled(false);
    } catch (error) {
        statusDiv.innerHTML = '<div class="error-message">Error fetching status</div>';
        setAllControlsDisabled(true);
    }
}

async function toggleUsbDebug(enabled) {
    if (!isEnvironmentSupported) return;
    
    try {
        await exec(`settings put global adb_enabled ${enabled ? '1' : '0'}`);
        updateStatus();
    } catch (error) {
        console.error('Error toggling USB debugging:', error);
    }
}



async function toggleWirelessAdb(enabled) {
    if (!isEnvironmentSupported) return;
    
    try {
        let port = parseInt(document.getElementById('portInput').value) || 5555;
        if (port < 1024 || port > 65535) {
            alert("Invalid port! Please enter a port between 1024 and 65535.");
            return;
        }

        await exec(`setprop service.adb.tcp.port ${enabled ? port : '-1'}`);
        await exec('stop adbd');
        await exec('start adbd');

        if (enabled && showNotifications) {
            await exec(`su -lp 2000 -c "cmd notification post -S bigtext -t 'WADBD' 'Tag' 'Wireless ADBD Enabled on port ${port} !!'" > /dev/null 2>&1`);
        }

        updateStatus();
    } catch (error) {
        console.error('Error toggling wireless ADB:', error);
    }
}

async function checkBootStatus() {
    try {
        const { stdout } = await exec(`[ -f "${MODULE_PATH}/service.sh" ] && echo "1" || echo "0"`);
        if (stdout === '1') {
            const { stdout: content } = await exec(`cat "${MODULE_PATH}/service.sh"`);
            return content.includes('setprop service.adb.tcp.port');
        }
        return false;
    } catch {
        return false;
    }
}

async function toggleBoot(enabled) {
    if (!isEnvironmentSupported) return;
    
    try {
        if (enabled) {
            let port = parseInt(document.getElementById('portInput').value) || 5555;
            if (port < 1024 || port > 65535) {
                alert("Invalid port! Please enter a port between 1024 and 65535.");
                return;
            }

            let script = `#!/system/bin/sh
while [ "$(getprop sys.boot_completed)" != "1" ]; do
    sleep 2
done
setprop service.adb.tcp.port ${port}
stop adbd
start adbd`;

            if (showNotifications) {
                script += `\nsu -lp 2000 -c "cmd notification post -S bigtext -t \\"WADBD\\" \\"Tag\\" \\"Wireless ADBD Enabled on port ${port} !!\\"" > /dev/null 2>&1`;
            }

            await exec(`mkdir -p "${MODULE_PATH}"`);
            await exec(`echo '${script}' > "${MODULE_PATH}/service.sh"`);
            await exec(`chmod 755 "${MODULE_PATH}/service.sh"`);
        } else {
            await exec(`rm -f "${MODULE_PATH}/service.sh"`);
        }
        updateStatus();
    } catch (error) {
        console.error('Error toggling boot status:', error);
    }
}

function setAllControlsDisabled(disabled) {
    const controls = [
        'usbDebugToggle',
        'wirelessToggle',
        'bootToggle',
        'portInput',
        'changePortBtn'
    ];
    
    controls.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.disabled = disabled;
        }
    });
}



document.getElementById('usbDebugToggle').addEventListener('change', (e) => {
    toggleUsbDebug(e.target.checked);
});

document.getElementById('wirelessToggle').addEventListener('change', (e) => {
    toggleWirelessAdb(e.target.checked);
});

document.getElementById('bootToggle').addEventListener('change', (e) => {
    toggleBoot(e.target.checked);
});

document.getElementById('changePortBtn').addEventListener('click', async () => {
    const wirelessEnabled = document.getElementById('wirelessToggle').checked;
    const bootEnabled = document.getElementById('bootToggle').checked;
    
    if (wirelessEnabled) {
        await toggleWirelessAdb(true);
    }
    if (bootEnabled) {
        await toggleBoot(true);
    }
});

async function updateConnectionInfo() {
    const connectionInfoDiv = document.getElementById('connectionInfo');
    
    if (!isEnvironmentSupported) {
        connectionInfoDiv.innerHTML = '<div class="error-message">Kernel SU API is missing. Unsupported Environment</div>';
        return;
    }

    try {
        const { stdout: wirelessPort } = await exec('getprop service.adb.tcp.port');
        const isWirelessEnabled = wirelessPort !== '' && wirelessPort !== '-1';
        
        if (!isWirelessEnabled) {
            connectionInfoDiv.innerHTML = `
                <div class="info-message">
                    Wireless ADB is currently disabled. Enable it to see connection commands.
                </div>
            `;
            return;
        }

        const { stdout: ipInfo } = await exec('ip -f inet addr show');
        
        const ipMatches = [...ipInfo.matchAll(/inet (\d+\.\d+\.\d+\.\d+).*(?:wlan|rmnet|eth)/g)];
        
        if (ipMatches.length === 0) {
            connectionInfoDiv.innerHTML = `
                <div class="warning-message">
                    No valid network interfaces found. Make sure you're connected to a network.
                </div>
            `;
            return;
        }

        let html = `
            <div class="connection-section">
                <div class="connection-header">Available Connection Commands:</div>
                <div class="network-interfaces">`;

        ipMatches.forEach(match => {
            const ip = match[1];
            html += `
                <div class="command-group">
                    <div class="interface-info">Interface IP: ${ip}</div>
                    <div class="command-box">
                        <code>adb connect ${ip}:${wirelessPort}</code>
                        <button class="copy-button" onclick="copyToClipboard('adb connect ${ip}:${wirelessPort}')">Copy</button>
                    </div>
                </div>
            `;
        });

        html += `
                </div>
                <div class="connection-note">
                    Note: Make sure ADB is installed on your computer and both devices are on the same network.
                </div>
            </div>`;

        connectionInfoDiv.innerHTML = html;
    } catch (error) {
        connectionInfoDiv.innerHTML = '<div class="error-message">Error fetching connection information</div>';
    }
}

function copyToClipboard(text) {
    navigator.clipboard.writeText(text).catch(err => {
        console.error('Failed to copy: ', err);
    });
}

window.onload = () => {
    setTheme(currentThemeIndex);
    initializeEnvironment();
    const notificationToggle = document.getElementById('notificationToggle');
    notificationToggle.checked = showNotifications;
};

document.getElementById('notificationToggle').addEventListener('change', (e) => {
    showNotifications = e.target.checked;
    localStorage.setItem('showNotifications', showNotifications);
});

setInterval(() => {
    updateStatus();
    updateConnectionInfo();
}, 2000);
